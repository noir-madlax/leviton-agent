-- Migration: Create Product Segmentation tables (v6.4)
-- Version: 003
-- Description: Implements the updated schema for product segmentation as per README_product_segmentation.md v6.4

-- ---------------------------------------------------------------------
-- 1. Run header table
-- ---------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS product_segment_runs (
    id                     VARCHAR(50) PRIMARY KEY,
    created_at             TIMESTAMPTZ  DEFAULT now(),
    stage                  VARCHAR(20)  DEFAULT 'init',

    seg_batches_done       INT          DEFAULT 0,
    seg_batches_total      INT,

    con_batches_done       INT          DEFAULT 0,
    con_batches_total      INT,

    ref_batches_done       INT          DEFAULT 0,
    ref_batches_total      INT,

    total_products         INT,
    processed_products     INT          DEFAULT 0,

    llm_config             JSONB,
    processing_params      JSONB,
    result_summary         JSONB
);

COMMENT ON TABLE product_segment_runs IS 'Tracks segmentation run metadata and stage-specific progress counters.';

-- Indexes to speed up common queries
CREATE INDEX IF NOT EXISTS idx_product_segment_runs_stage ON product_segment_runs(stage);
CREATE INDEX IF NOT EXISTS idx_product_segment_runs_created_at ON product_segment_runs(created_at);

-- ---------------------------------------------------------------------
-- 2. Taxonomy definitions table
-- ---------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS product_segment_taxonomies (
    id            BIGSERIAL PRIMARY KEY,
    run_id        VARCHAR(50) REFERENCES product_segment_runs(id) ON DELETE CASCADE,
    segment_name  VARCHAR(255),
    definition    TEXT,
    stage         VARCHAR(30)   DEFAULT 'extraction'
);

COMMENT ON TABLE product_segment_taxonomies IS 'Stores taxonomy/segment definitions generated throughout the segmentation pipeline.';

CREATE INDEX IF NOT EXISTS idx_product_segment_taxonomies_run_id ON product_segment_taxonomies(run_id);
CREATE INDEX IF NOT EXISTS idx_product_segment_taxonomies_stage  ON product_segment_taxonomies(stage);

-- ---------------------------------------------------------------------
-- 3. Unified product assignment table
-- ---------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS product_segment_assignments (
    run_id               VARCHAR(50) REFERENCES product_segment_runs(id) ON DELETE CASCADE,
    product_id           BIGINT      REFERENCES amazon_products(id),
    taxonomy_id_initial  BIGINT      REFERENCES product_segment_taxonomies(id),
    taxonomy_id_refined  BIGINT      REFERENCES product_segment_taxonomies(id),
    PRIMARY KEY (run_id, product_id)
);

COMMENT ON TABLE product_segment_assignments IS 'Holds both initial and refined taxonomy assignments for each product.';

CREATE INDEX IF NOT EXISTS idx_product_segment_assignments_product_id ON product_segment_assignments(product_id);
CREATE INDEX IF NOT EXISTS idx_product_segment_assignments_taxonomy_initial ON product_segment_assignments(taxonomy_id_initial);
CREATE INDEX IF NOT EXISTS idx_product_segment_assignments_taxonomy_refined ON product_segment_assignments(taxonomy_id_refined);

-- ---------------------------------------------------------------------
-- 4. LLM interactions index table
-- ---------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS product_segment_llm_interactions (
    id          BIGSERIAL PRIMARY KEY,
    run_id      VARCHAR(50) REFERENCES product_segment_runs(id) ON DELETE CASCADE,
    file_path   TEXT UNIQUE,
    cache_key   VARCHAR(32),
    created_at  TIMESTAMPTZ DEFAULT now()
);

COMMENT ON TABLE product_segment_llm_interactions IS 'Index of on-disk/S3 files generated by LLM interactions within a segmentation run.';

CREATE INDEX IF NOT EXISTS idx_product_segment_llm_interactions_run_id ON product_segment_llm_interactions(run_id);
CREATE INDEX IF NOT EXISTS idx_product_segment_llm_interactions_cache_key ON product_segment_llm_interactions(cache_key);

-- ---------------------------------------------------------------------
-- 5. Seed placeholder taxonomy rows
-- ---------------------------------------------------------------------
-- These inserts align with the lifecycle described in the README. They use
-- PostgreSQL functions to insert for every new run via a trigger.
-- We create a helper function + trigger so that any application-side inserts
-- into product_segment_runs automatically create the placeholder taxonomies.

CREATE OR REPLACE FUNCTION _insert_default_taxonomies() RETURNS TRIGGER AS $$
BEGIN
    -- Unassigned bucket
    INSERT INTO product_segment_taxonomies (run_id, segment_name, definition, stage)
    VALUES (NEW.id, '__UNASSIGNED__', 'Auto-generated placeholder', 'init');

    -- Out-of-scope bucket
    INSERT INTO product_segment_taxonomies (run_id, segment_name, definition, stage)
    VALUES (NEW.id, '__OUT_OF_SCOPE__', 'Products totally irrelevant to the current category', 'system');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_default_taxonomies ON product_segment_runs;
CREATE TRIGGER trg_default_taxonomies
AFTER INSERT ON product_segment_runs
FOR EACH ROW EXECUTE PROCEDURE _insert_default_taxonomies();

-- End of migration 